import numpy as np
import random
from RANDOM_SEARCH import (
   GET_STATION_LOCATIONS,
   CREATE_DISTANCE_MATRIX,
   CALCULATE_PATH_DISTANCE,
)
from NEAREST_NEIGHBOR_SEARCH import (
   NEAREST_NEIGHBOR_SEARCH,
   TWO_OPT_SEARCH,
)


def KMEANS_SINGLE_RUN(STATION_LOCATIONS, NUM_OF_CLUSTERS, MAX_ITERATIONS):
   NUM_LOCATIONS = len(STATION_LOCATIONS)
   RANDOM_INDEX_LIST = random.sample(range(NUM_LOCATIONS), NUM_OF_CLUSTERS)
   CLUSTER_LANDING_PAD = []


   for i in RANDOM_INDEX_LIST:
       CLUSTER_LANDING_PAD.append([STATION_LOCATIONS[i][0], STATION_LOCATIONS[i][1]])
  
   for i in range(MAX_ITERATIONS):
       DISTANCES = [[0.0] * NUM_OF_CLUSTERS for _ in range(NUM_LOCATIONS)]
  
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
               X = STATION_LOCATIONS[LOCATION_INDEX][0] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][0]
               Y = STATION_LOCATIONS[LOCATION_INDEX][1] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][1]
               DISTANCE = X*X + Y*Y
               DISTANCES[LOCATION_INDEX][CLUSTER_INDEX] = DISTANCE


       CLUSTER_IDS = []
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           MIN_DISTANCE = float('inf')
           BEST_CLUSTER = 0
           for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
               if DISTANCES[LOCATION_INDEX][CLUSTER_INDEX] < MIN_DISTANCE:
                   MIN_DISTANCE = DISTANCES[LOCATION_INDEX][CLUSTER_INDEX]
                   BEST_CLUSTER = CLUSTER_INDEX
           CLUSTER_IDS.append(BEST_CLUSTER)
      
       NEW_CLUSTER_LANDING_PAD = [[0.0, 0.0] for _ in range(NUM_OF_CLUSTERS)]
       CLUSTER_COUNT = [0] * NUM_OF_CLUSTERS
      
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] += STATION_LOCATIONS[LOCATION_INDEX][0]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] += STATION_LOCATIONS[LOCATION_INDEX][1]
           CLUSTER_COUNT[CLUSTER_INDEX] += 1
      
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           if CLUSTER_COUNT[CLUSTER_INDEX] == 0:
               RANDOM_INDEX = random.randint(0, NUM_LOCATIONS - 1)
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX] = [STATION_LOCATIONS[RANDOM_INDEX][0], STATION_LOCATIONS[RANDOM_INDEX][1]]
           else:
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] /= CLUSTER_COUNT[CLUSTER_INDEX]
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] /= CLUSTER_COUNT[CLUSTER_INDEX]
      
       CONVERGED = True
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           X = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0])
           Y = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1])
           if X > 1e-6 or Y > 1e-6:
               CONVERGED = False
               break
      
       if CONVERGED:
           CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
           break
  
       CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
  
   SUM_OF_DISTANCE = 0.0
   for LOCATION_INDEX in range(NUM_OF_CLUSTERS):
       CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
       NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] += STATION_LOCATIONS[LOCATION_INDEX][0]
       NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] += STATION_LOCATIONS[LOCATION_INDEX][1]
       CLUSTER_COUNT[CLUSTER_INDEX] += 1


   for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
       if CLUSTER_COUNT[CLUSTER_INDEX] == 0:
           RANDOM_INDEX = random.randint(0, NUM_LOCATIONS - 1)
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX] = [STATION_LOCATIONS[RANDOM_INDEX][0], STATION_LOCATIONS[RANDOM_INDEX][1]]
       else:
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] /= CLUSTER_COUNT[CLUSTER_INDEX]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] /= CLUSTER_COUNT[CLUSTER_INDEX]
      
       CONVERGED = True
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           X = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0])
           Y = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1])
           if X > 1e-6 or Y > 1e-6:
               CONVERGED = False
               break
      
       if CONVERGED:
           CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
           break
  
       CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
  
   SUM_OF_DISTANCE = 0.0
   for LOCATION_INDEX in range(NUM_LOCATIONS):
       CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
       X = STATION_LOCATIONS[LOCATION_INDEX][0] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][0]
       Y = STATION_LOCATIONS[LOCATION_INDEX][1] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][1]
       SUM_OF_DISTANCE += X*X + Y*Y
  
   return CLUSTER_IDS, CLUSTER_LANDING_PAD, SUM_OF_DISTANCE




def KMEANS_CLUSTERING(STATION_LOCATIONS, NUM_OF_CLUSTERS, MAX_ITERATIONS):
   RESULTS = {}


   for K in range(1, 5):
       BEST_SUM_OF_DISTANCE = float('inf')
       BEST_CLUSTER_IDS = None
       BEST_CLUSTER_LANDING_PAD = None
      
       for i in range(NUM_OF_CLUSTERS):
           CLUSTER_IDS, CLUSTER_LANDING_PAD, SUM_OF_DISTANCE = KMEANS_SINGLE_RUN(STATION_LOCATIONS, K, MAX_ITERATIONS)
          
           if SUM_OF_DISTANCE < BEST_SUM_OF_DISTANCE:
               BEST_SUM_OF_DISTANCE = SUM_OF_DISTANCE
               BEST_CLUSTER_IDS = CLUSTER_IDS
               BEST_CLUSTER_LANDING_PAD = CLUSTER_LANDING_PAD
      
       RESULTS[K] = (BEST_CLUSTER_IDS, BEST_CLUSTER_LANDING_PAD, BEST_SUM_OF_DISTANCE)


   return RESULTS



def CLUSTER_TSP_SOLVER(CLUSTER_LOCATIONS, LANDING_PAD, MAX_ITERATIONS):
    NUM_OF_LOCATIONS = [LANDING_PAD] + CLUSTER_LOCATIONS
    DISTANCE_MATRIX = CREATE_DISTANCE_MATRIX(NUM_OF_LOCATIONS)
    
    NN_PATH = NEAREST_NEIGHBOR_SEARCH(DISTANCE_MATRIX)
    OPTIMIZED_PATH = TWO_OPT_SEARCH(NN_PATH, DISTANCE_MATRIX, MAX_ITERATIONS)
    
    ROUTE_DISTANCE = CALCULATE_PATH_DISTANCE(OPTIMIZED_PATH, DISTANCE_MATRIX)
    
    return OPTIMIZED_PATH, ROUTE_DISTANCE



def SOLVE_MULTI_DRONE_PROBLEM(STATION_LOCATIONS, K, MAX_ITERATIONS, RESULTS):
    NUM_OF_LOCATIONS = len(STATION_LOCATIONS)
    ROUTES = []
    DISTANCES = []
    FLIGHT_TIMES = []
    CLUSTER_IDS, CLUSTER_LANDING_PAD, SUM_OF_DISTANCE = RESULTS[K]
    
    for CLUSTER_ID in range(K):
        CLUSTER_INDEX = []
        for LOCATION_INDEX in range(NUM_OF_LOCATIONS):
            if CLUSTER_IDS[LOCATION_INDEX] == CLUSTER_ID:
                CLUSTER_INDEX.append(LOCATION_INDEX)

        CLUSTER_LOCATIONS = []
        for LOCATION_INDEX in CLUSTER_INDEX:
            CLUSTER_LOCATIONS.append(STATION_LOCATIONS[LOCATION_INDEX])

        LANDING_PAD = CLUSTER_LANDING_PAD[CLUSTER_ID]
        
        ROUTE, DISTANCE = CLUSTER_TSP_SOLVER(CLUSTER_LOCATIONS, LANDING_PAD, MAX_ITERATIONS)
        FLIGHT_TIME = DISTANCE / 100.0
        
        ROUTES.append(ROUTE)
        DISTANCES.append(DISTANCE)
        FLIGHT_TIMES.append(FLIGHT_TIME)
    
    MAX_FLIGHT_TIME = max(FLIGHT_TIMES)
    SETUP_TIME = 2.0 * K
    TOTAL_TIME = MAX_FLIGHT_TIME + SETUP_TIME
    
    SOLUTION = {'K': K, 'clusters': CLUSTER_IDS, 'landing_pad': CLUSTER_LANDING_PAD, 'routes': ROUTES, 'distances': DISTANCES,'flight_times': FLIGHT_TIMES,
                'total_time': TOTAL_TIME, 'max_flight_time': MAX_FLIGHT_TIME, 'setup_time': SETUP_TIME, 'SUM_OF_DISTANCE': SUM_OF_DISTANCE}
    
    return SOLUTION



def OPTIMIZE_MULTI_DRONE_ROUTES(FILE_NAME, MAX_ITERATIONS=100, NUM_RESTARTS=10):
    from RANDOM_SEARCH import GET_STATION_LOCATIONS
    print("ComputePossibleSolutions")
    STATION_LOCATIONS = GET_STATION_LOCATIONS(FILE_NAME)
    NUM_OF_LOCATIONS = len(STATION_LOCATIONS)
    
    print(f"Enter the name of file: {FILE_NAME}")
    print(f"There are {NUM_OF_LOCATIONS} nodes: Solutions will be available by 7:04am") # time change
    
    KMEANS_RESULTS = KMEANS_CLUSTERING(STATION_LOCATIONS, NUM_RESTARTS, MAX_ITERATIONS)
    SOLUTIONS = {}
    
    for K in range(1, 5):
        SOLUTION = SOLVE_MULTI_DRONE_PROBLEM(STATION_LOCATIONS, K, MAX_ITERATIONS, KMEANS_RESULTS)
        SOLUTIONS[K] = SOLUTION

    for K in range(1, 5):
        SOLUTION = SOLUTIONS[K]
        CLUSTER_IDS = SOLUTION['clusters']
        LANDING_PAD = SOLUTION['landing_pad']
        DISTANCES = SOLUTION['distances']
        MAX_DISTANCE = max(DISTANCES)
        
        print(f"{K}) If you use {K} drone(s), the total route will be {MAX_DISTANCE:.1f} meters")
        
        for DRONE_ID in range(K):
            LANDING_PAD = LANDING_PAD[DRONE_ID]
            DISTANCE = DISTANCES[DRONE_ID]
            NUM_LOCATIONS_IN_CLUSTER = sum(1 for cid in CLUSTER_IDS if cid == DRONE_ID)
            LANDING_PAD_X = int(round(LANDING_PAD[0]))
            LANDING_PAD_Y = int(round(LANDING_PAD[1]))
            
            print(f"   {'i' * (DRONE_ID + 1)}. Landing Pad {DRONE_ID + 1} should be at [{LANDING_PAD_X},{LANDING_PAD_Y}], serving {NUM_LOCATIONS_IN_CLUSTER} locations, route is {DISTANCE:.1f} meters")
    

    SELECTED_K = int(input("\nPlease select your choice 1 to 4: "))
    
    BASE_FILENAME = FILE_NAME.rsplit('.', 1)[0]
    SELECTED_SOLUTION = SOLUTIONS[SELECTED_K]
    
    WRITE_ROUTE_FILES(SELECTED_SOLUTION, BASE_FILENAME, SELECTED_K)
    
    return SOLUTIONS



def WRITE_ROUTE_FILES(SOLUTION, BASE_FILENAME, K):
    CLUSTER_IDS = SOLUTION['clusters']
    NUM_OF_LOCATIONS = len(CLUSTER_IDS)
    
    for DRONE_ID in range(K):
        ROUTE = SOLUTION['routes'][DRONE_ID]
        DISTANCE = int(SOLUTION['distances'][DRONE_ID])
        CLUSTER_LOCATION_INDICES = []

        for LOCATION_INDEX in range(NUM_OF_LOCATIONS):
            if CLUSTER_IDS[LOCATION_INDEX] == DRONE_ID:
                CLUSTER_LOCATION_INDICES.append(LOCATION_INDEX + 1)

        ACTUAL_ROUTE = []
        for NODE in ROUTE[1:-1]:
            if NODE > 0:
                ACTUAL_LOCATION = CLUSTER_LOCATION_INDICES[NODE - 1]
                ACTUAL_ROUTE.append(ACTUAL_LOCATION)
        
        OUTPUT_FILENAME = f"{BASE_FILENAME}_{DRONE_ID + 1}_SOLUTION_{DISTANCE}.txt"
        with open(OUTPUT_FILENAME, 'w') as FILE:
            FILE.write(' '.join(map(str, ACTUAL_ROUTE)))
    
    FILE_LIST = [f"{BASE_FILENAME}_{i+1}_SOLUTION_{int(SOLUTION['distances'][i])}.txt" for i in range(K)]
    print(f"Writing {', '.join(FILE_LIST)} to disk")