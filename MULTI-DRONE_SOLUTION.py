import numpy as np
import random
from RANDOM_SEARCH import (
   GET_STATION_LOCATIONS,
   CREATE_DISTANCE_MATRIX,
   CALCULATE_PATH_DISTANCE,
)
from NEAREST_NEIGHBOR_SEARCH import (
   NEAREST_NEIGHBOR_SEARCH,
   TWO_OPT_SEARCH,
)


def KMEANS_SINGLE_RUN(STATION_LOCATIONS, NUM_OF_CLUSTERS, MAX_ITERATIONS):
   NUM_LOCATIONS = len(STATION_LOCATIONS)
   RANDOM_INDEX_LIST = random.sample(range(NUM_LOCATIONS), NUM_OF_CLUSTERS)
   CLUSTER_LANDING_PAD = []


   for i in RANDOM_INDEX_LIST:
       CLUSTER_LANDING_PAD.append([STATION_LOCATIONS[i][0], STATION_LOCATIONS[i][1]])
  
   for i in range(MAX_ITERATIONS):
       DISTANCES = [[0.0] * NUM_OF_CLUSTERS for _ in range(NUM_LOCATIONS)]
  
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
               X = STATION_LOCATIONS[LOCATION_INDEX][0] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][0]
               Y = STATION_LOCATIONS[LOCATION_INDEX][1] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][1]
               DISTANCE = X*X + Y*Y
               DISTANCES[LOCATION_INDEX][CLUSTER_INDEX] = DISTANCE


       CLUSTER_IDS = []
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           MIN_DISTANCE = float('inf')
           BEST_CLUSTER = 0
           for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
               if DISTANCES[LOCATION_INDEX][CLUSTER_INDEX] < MIN_DISTANCE:
                   MIN_DISTANCE = DISTANCES[LOCATION_INDEX][CLUSTER_INDEX]
                   BEST_CLUSTER = CLUSTER_INDEX
           CLUSTER_IDS.append(BEST_CLUSTER)
      
       NEW_CLUSTER_LANDING_PAD = [[0.0, 0.0] for _ in range(NUM_OF_CLUSTERS)]
       CLUSTER_COUNT = [0] * NUM_OF_CLUSTERS
      
       for LOCATION_INDEX in range(NUM_LOCATIONS):
           CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] += STATION_LOCATIONS[LOCATION_INDEX][0]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] += STATION_LOCATIONS[LOCATION_INDEX][1]
           CLUSTER_COUNT[CLUSTER_INDEX] += 1
      
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           if CLUSTER_COUNT[CLUSTER_INDEX] == 0:
               RANDOM_INDEX = random.randint(0, NUM_LOCATIONS - 1)
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX] = [STATION_LOCATIONS[RANDOM_INDEX][0], STATION_LOCATIONS[RANDOM_INDEX][1]]
           else:
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] /= CLUSTER_COUNT[CLUSTER_INDEX]
               NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] /= CLUSTER_COUNT[CLUSTER_INDEX]
      
       CONVERGED = True
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           X = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0])
           Y = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1])
           if X > 1e-6 or Y > 1e-6:
               CONVERGED = False
               break
      
       if CONVERGED:
           CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
           break
  
       CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
  
   SUM_OF_DISTANCE = 0.0
   for LOCATION_INDEX in range(NUM_OF_CLUSTERS):
       CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
       NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] += STATION_LOCATIONS[LOCATION_INDEX][0]
       NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] += STATION_LOCATIONS[LOCATION_INDEX][1]
       CLUSTER_COUNT[CLUSTER_INDEX] += 1


   for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
       if CLUSTER_COUNT[CLUSTER_INDEX] == 0:
           RANDOM_INDEX = random.randint(0, NUM_LOCATIONS - 1)
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX] = [STATION_LOCATIONS[RANDOM_INDEX][0], STATION_LOCATIONS[RANDOM_INDEX][1]]
       else:
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] /= CLUSTER_COUNT[CLUSTER_INDEX]
           NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] /= CLUSTER_COUNT[CLUSTER_INDEX]
      
       CONVERGED = True
       for CLUSTER_INDEX in range(NUM_OF_CLUSTERS):
           X = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][0] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][0])
           Y = abs(CLUSTER_LANDING_PAD[CLUSTER_INDEX][1] - NEW_CLUSTER_LANDING_PAD[CLUSTER_INDEX][1])
           if X > 1e-6 or Y > 1e-6:
               CONVERGED = False
               break
      
       if CONVERGED:
           CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
           break
  
       CLUSTER_LANDING_PAD = NEW_CLUSTER_LANDING_PAD
  
   SUM_OF_DISTANCE = 0.0
   for LOCATION_INDEX in range(NUM_LOCATIONS):
       CLUSTER_INDEX = CLUSTER_IDS[LOCATION_INDEX]
       X = STATION_LOCATIONS[LOCATION_INDEX][0] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][0]
       Y = STATION_LOCATIONS[LOCATION_INDEX][1] - CLUSTER_LANDING_PAD[CLUSTER_INDEX][1]
       SUM_OF_DISTANCE += X*X + Y*Y
  
   return CLUSTER_IDS, CLUSTER_LANDING_PAD, SUM_OF_DISTANCE




def KMEANS_CLUSTERING(STATION_LOCATIONS, NUM_OF_CLUSTERS, MAX_ITERATIONS):
   RESULTS = {}


   for K in range(1, 5):
       BEST_SUM_OF_DISTANCE = float('inf')
       BEST_CLUSTER_IDS = None
       BEST_CLUSTER_LANDING_PAD = None
      
       for i in range(NUM_OF_CLUSTERS):
           CLUSTER_IDS, CLUSTER_LANDING_PAD, SUM_OF_DISTANCE = KMEANS_SINGLE_RUN(STATION_LOCATIONS, K, MAX_ITERATIONS)
          
           if SUM_OF_DISTANCE < BEST_SUM_OF_DISTANCE:
               BEST_OBJECTIVE_FUNCTION = SUM_OF_DISTANCE
               BEST_CLUSTER_IDS = CLUSTER_IDS
               BEST_CLUSTER_LANDING_PAD = CLUSTER_LANDING_PAD
      
       RESULTS[K] = (BEST_CLUSTER_IDS, BEST_CLUSTER_LANDING_PAD, BEST_OBJECTIVE_FUNCTION)


   return RESULTS